# This is an initial script for nushell
# It is expected that it is sourced in the `config.toml`:
# `startup = ["source ~/.config/nushell/nurc"]`

# GLOBAL VARIABLES
let-env NURC = (build-string (pwd) /nurc)
let-env DOTFILES = ((build-string (pwd) /..) | path expand)
let-env TODO = (build-string $nu.env.DOTFILES /TODO.md)

# ALIASES
alias cat = bat
alias vim = nvim
alias edit = nvim
alias e = nvim
alias ll = exa --group-directories-first --classify --long --icons --git
alias la = exa --group-directories-first --classify --all --long --icons --git
alias tr = exa --tree
alias doas = sudo
alias grep = rg

# CUSTOM LITTLE JAVA COMMANDS
alias sha = java (build-string $nu.env.DOTFILES /tools/ sha.java)
alias aes = java (build-string $nu.env.DOTFILES /tools/ aes.java)
alias uuid = java (build-string $nu.env.DOTFILES /tools/ random_uuid.java)
alias download = java (build-string $nu.env.DOTFILES /tools/ download.java)
alias download_jar = java (build-string $nu.env.DOTFILES /tools/ download_jar.java)

# MY STDLIB UTIL MISC HELPER FUNCTIONS

# Check whether table in pipeline has a column with given name
def "has-column?" [
  name: string # Name of the column to check for
] {
  pivot | any? Column0 == $name
}

# Prints out a list of stuff.
# Appends a newline at the end.
def print [
  ...rest: any # list of stuff to echo out
] {
  echo (build-string ($rest | flatten | into string | str collect) )
  echo (char newline)
}

# Flattens a table into a string separated by a single space character.
def to-string [] { flatten | into string | str collect ' ' }

# FUNCTIONS

# Render my To-Do file in the terminal
def todo [] { mdcat $nu.env.TODO }
# Open my To-Do file for editing
def "todo edit" [] { nvim $nu.env.TODO }
# Open the Nushell configuration file for editing
def "config edit" [] { nvim (config path) }
# Open my Nushell startup script for editing
def nurc [] { nvim $nu.env.NURC }

# Uploads a PUBLIC ssh key to GitHub.
# Will prompt for the AES encryption password of my dotfiles.
def github-upload-key [
  title: string # Name the key, so you will remember what it is used for
  key: path     # Path to the PUBLIC key
] {
  if ($key | path exists) {
    echo (build-string "uploading ssh public key " (ansi gi) $key (ansi reset) " with title " (ansi gb) $title (ansi reset) " to GitHub.") 
    echo (char newline)
    let encrypted_token_path = (build-string $nu.env.DOTFILES / tresor / 4cef0ce3-da3a-4f16-9412-2d094b4f7445)
    let decrypted_token_path = (build-string $nu.env.DOTFILES / tresor / gh_token)
    aes decrypt $encrypted_token_path $decrypted_token_path 
    let token = (open --raw $decrypted_token_path)
    let key_content = (open --raw $key)
    rm -f $decrypted_token_path
    let result = (do -i { xh --bearer $token https://api.github.com/user/keys (build-string title = $title) (build-string key = $key_content) | from json})
    if ($result | has-column? errors) {
      let message = ($result | get message)
      let url = ($result | get documentation_url)
      let errors = ($result | get errors)
      echo (build-string (ansi rb) $message (ansi reset) (char newline))
      echo (char newline)
      $errors | each {
        let resource = ($it | get resource)
        let code = ($it | get code)
        let field = ($it | get field)
        let message = ($it | get message)
        echo (build-string (ansi ui) $resource : $code : $field ": " (ansi rb) $message (ansi reset) (char newline))
      }
      echo (build-string "Further information: " (ansi yi) $url (ansi reset) (char newline))
    } {
      let id = ($result | get id)
      let key = ($result | get key)
      let title = ($result | get title)
      let created_at = ($result | get created_at)
      echo (build-string "[" ID : $id "]" " key with title " (ansi gb) $title (ansi reset) " was created at " (ansi yi) $created_at (ansi reset) "." (char newline) )
      echo (build-string (ansi wu) "PUBLIC SSH KEY:" (ansi reset))
      echo (char newline)
      echo ($key | ansi gradient --fgstart 0xaefe9f --fgend 0xfefefe)
      echo (char newline)
    }
  } {
    echo (build-string "key " (ansi rb) $key (ansi reset) " not found!")
      echo (char newline)
  }
}

# Shows git log in a pretty table
def glog [
  ...rest: string # Extra arguments to git log
] {
  git log --pretty=%h»¦«%s»¦«%aN»¦«%aE»¦«%aD -n 25 $rest | lines | split column "»¦«" commit subject name email date | update date { get date | str to-datetime} | sort-by date
}


# Open manual page.
# On Windows, a man web page is opened.
def man [
  ...rest: string # Arguments to man
] {
  if (sys).host.name == "Windows" {
    start (build-string https://man.cx/ ($rest | to-string))
  } {
    exec man $rest
  }
}

# Search the given query on the web with the default browser in DuckDuckGo.
def web [
  ...rest:string # The search query
] {
    # There seems to be an issue with the nu start command on windows: It does not handle URLs
    # Using windows command for now:
    start (build-string "https://duckduckgo.com/?q=" ($rest | to-string))
}

