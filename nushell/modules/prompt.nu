# Custom integration of zoxide into nushell.
# Since nushell 0.60.0 the autogenerated code of zoxide is no longer useful.
# =============================================================================
#
# Hook configuration for zoxide.
#

# Hook to add new entries to the database.
# This hook gets exported out of the module so that it can be integrated inot the prompt
def zoxide-hook [] {
  shells
  | where active == true
  | get path
  | each { | path | zoxide add -- $path  }
  | ignore
}

# =============================================================================

# Jump to a directory using only keywords.
export def-env zoxide-jump [...rest:string] {
  let span = (metadata $rest).span
  #normalize path
  let pwd = ($env.PWD | path expand)
  let z_jump = ( do --ignore-errors { zoxide query --exclude $pwd -- $rest } )

  if ($z_jump | empty?) {
    error make {
      msg: "Zoxide could not find any match for the given query.",
      label: {
        text: "no matches for this query",
        start: $span.start,
        end: $span.end
      }
    }
  }

  # zoxide returns even single results with a newline at the end...
  cd ($z_jump | str trim --right --char (char newline) )
}

export alias z = zoxide-jump

# Map of paths to icons.
# These will be used to replace certain path segments in the prompt for example.
# Order these paths for precedence.
def icons [] {
    [
        [ path icon ];
        [ "/home/oli/Notes" (char -u "1f4d3") ]
        [ "C:\\Users\\okr\\Notes" (char -u "1f4d3") ]
        [ "/home/oli/Workspace" (char -u "1f4bb") ]
        [ "C:\\Users\\okr\\Workspaces" (char -u "1f4bb") ]
        [ "/home/oli" (char nf_house2) ]
        [ "C:\\Users\\okr" (char nf_house2) ]
    ]
}

# Uses a special escape code to set the window title of the terminal emulator.
# This will be ignored in terminal emulator, that do not support that escape code.
# The title to be set is derived from the current working directory.
# Special types of directories, e.g. HOME, get custom icons.
def set-window-title [] {
    # normalize path
    let pwd = ( $env.PWD | path expand )
    let icon = if (icons | any? path == $pwd) { ( icons | where path == $pwd | get icon.0 ) } else { $"(char nf_folder1)" }
    # Some terminals freeze, if they do not support this OSC
    if (env | any? name == TERM_PROGRAM) && $env.TERM_PROGRAM == WezTerm {
      echo ([ (ansi title) $icon " " ( $pwd | path basename ) (ansi reset) ] | str collect)
    }
}

def get_vcs_path [] {
    #normalize path
    let pwd = ($env.PWD | path expand)

    let svn_relative_cmd = ( do --ignore-errors { ^svn info --show-item relative-url --no-newline $pwd } | complete )
    let svn_relative_path = if ($svn_relative_cmd.exit_code == 0) { $" 🐢 (char nf_branch) ($svn_relative_cmd.stdout)" }

    let git_status = ( gstat )
    let git_branch = if ( $git_status.branch != "no_branch" ) { $" (char nf_git) (char nf_branch) ($git_status.branch)" }

    [
      $svn_relative_path
      $git_branch
    ] | str collect
}

def create_left_prompt [] {
    zoxide-hook
    set-window-title

    # normalize path
    let pwd = ($env.PWD | path expand)
    let pwd = (icons | reduce --fold $pwd { |item, accumulator| $accumulator | str replace --string $item.path $item.icon })
    let truncate_level = 5
    let truncate_symbol = $"…(char path_sep)"
    let path_segment = if ($pwd | path split | length) >= $truncate_level { ($pwd | path dirname --num-levels 2 --replace $truncate_symbol ) } else { $pwd }

    let vcs_segment = get_vcs_path

    [
      (ansi dark_gray)
      $path_segment
      (ansi reset)
      (ansi green)
      $vcs_segment
      (ansi reset)
    ] | str collect
}

def create_right_prompt [] {
    let time_segment = ([
        (date now | date format '%d.%m %R')
    ] | str collect)

    let command_status_segment = if $env.LAST_EXIT_CODE == 0 { $" (char -u '2713') " } else { $"(ansi red) (char failed) (ansi reset)" }
    let command_duration_segment = if ( $env.CMD_DURATION_MS | into int) > 0 { $"($env.CMD_DURATION_MS)ms" | into duration }

    [
      (ansi dark_gray_dimmed)
      $command_duration_segment
      (ansi reset)
      (ansi dark_gray)
      $command_status_segment
      (ansi reset)
      (ansi dark_gray)
      $time_segment
      (ansi reset)
    ] | str collect
}

# Use nushell functions to define your right and left prompt
export env PROMPT_COMMAND { {create_left_prompt} }
export env PROMPT_COMMAND_RIGHT { {create_right_prompt} }

# The prompt indicators are environmental variables that represent
# the state of the prompt
export env PROMPT_INDICATOR { $"(ansi purple) (char prompt) (ansi reset)" }
export env PROMPT_INDICATOR_VI_INSERT { $"(ansi purple_reverse) (char pipe) (ansi reset)" }
export env PROMPT_INDICATOR_VI_NORMAL { $"(ansi purple_bold) (char prompt) (ansi reset)" }
export env PROMPT_MULTILINE_INDICATOR { $"(ansi purple_dimmed)(char prompt)(char prompt) (ansi reset)" }
