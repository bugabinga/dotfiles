# Nushell Config File

# GLOBAL VARIABLES
let-env NURC_DIR = ($nu.config-path | path dirname | path expand)
let-env DOTFILES = ($env.NURC_DIR| path join ".." | path expand)
let-env TODO = ($env.DOTFILES | path join "TODO.md")

# ALIASES
alias cat = bat
alias vim = hx
alias edit = hx
alias e = hx

alias ll = exa --group-directories-first --classify --long --icons --git
alias la = exa --group-directories-first --classify --all --long --icons --git
alias tr = exa --tree

alias grep = rg

# CUSTOM LITTLE JAVA COMMANDS
alias aes = java (build-string $env.DOTFILES /tools/ aes.java)
alias download = java (build-string $env.DOTFILES /tools/ download.java)
alias download_jar = java (build-string $env.DOTFILES /tools/ download_jar.java)


# MY STDLIB UTIL MISC HELPER FUNCTIONS

# Check whether table in pipeline has a column with given name
def "has-column?" [
  name: string # Name of the column to check for
] {
  pivot | any? Column0 == $name
}

# Flattens a table into a string separated by a single space character.
def to-string [] { flatten | into string | str collect ' ' }

# FUNCTIONS

# Render my To-Do file in the terminal
def todo [] { mdcat $env.TODO }
# Open my To-Do file for editing
def "todo edit" [] { hx $env.TODO }
# Show the nushell config
def config [] { bat $nu.config-path }
# Open the Nushell configuration file for editing
def "config edit" [] { hx $nu.config-path }

def github-upload-key [
  title: string # Name the key, so you will remember what it is used for
  key: path     # Path to the PUBLIC key
] {
  if ($key | path exists) {
    echo (build-string "uploading ssh public key " (ansi gi) $key (ansi reset) " with title " (ansi gb) $title (ansi reset) " to GitHub.") 
    echo (char newline)
    let encrypted_token_path = (build-string $env.DOTFILES / tresor / 4cef0ce3-da3a-4f16-9412-2d094b4f7445)
    let decrypted_token_path = (build-string $env.DOTFILES / tresor / gh_token)
    aes decrypt $encrypted_token_path $decrypted_token_path 
    let token = (open --raw $decrypted_token_path)
    let key_content = (open --raw $key)
    rm -f $decrypted_token_path
    let result = (do -i { xh --bearer $token https://api.github.com/user/keys (build-string title = $title) (build-string key = $key_content) | from json})
    if ($result | has-column? errors) {
      let message = ($result | get message)
      let url = ($result | get documentation_url)
      let errors = ($result | get errors)
      echo (build-string (ansi rb) $message (ansi reset) (char newline))
      echo (char newline)
      $errors | each {
        | it |
        let resource = ($it | get resource)
        let code = ($it | get code)
        let field = ($it | get field)
        let message = ($it | get message)
        echo (build-string (ansi ui) $resource : $code : $field ": " (ansi rb) $message (ansi reset) (char newline))
      }
      echo (build-string "Further information: " (ansi yi) $url (ansi reset) (char newline))
    } else {
      let id = ($result | get id)
      let key = ($result | get key)
      let title = ($result | get title)
      let created_at = ($result | get created_at)
      echo (build-string "[" ID : $id "]" " key with title " (ansi gb) $title (ansi reset) " was created at " (ansi yi) $created_at (ansi reset) "." (char newline) )
      echo (build-string (ansi wu) "PUBLIC SSH KEY:" (ansi reset))
      echo (char newline)
      echo ($key | ansi gradient --fgstart 0xaefe9f --fgend 0xfefefe)
      echo (char newline)
    }
  } else {
    echo (build-string "key " (ansi rb) $key (ansi reset) " not found!")
    echo (char newline)
  }
}

# Shows git log in a pretty table
def glog [
  ...rest: string # Extra arguments to git log
] {
  git log --pretty=%h»¦«%s»¦«%aN»¦«%aE»¦«%aD -n 25 $rest | lines | split column "»¦«" commit subject name email date | update date { get date | into datetime} | sort-by date
}

# Open manual page.
# On Windows, a man web page is opened.
def man [
  ...rest: string # Arguments to man
] {
  if (sys).host.name == "Windows" {
    start (build-string https://man.archlinux.org/man/ ($rest | to-string))
  } else {
    ^man $rest
  }
}

# Search the given query on the web with the default browser in DuckDuckGo.
def web [
  ...rest:string # The search query
] {
  let query = (build-string "https://duckduckgo.com/?q=" ($rest | to-string))
  if (sys).host.name == "Windows" {
    # There seems to be an issue with the nu start command on windows: It does not handle URLs
    # Using windows command for now:
    start $query
  } else {
    xdg-open $query
  }
}

# Custom integration of zoxide into nushell.
# Since nushell 0.60.0 the autogenerated code of zoxide is no longer useful.
# =============================================================================
#
# Hook configuration for zoxide.
#

# Hook to add new entries to the database.
# This hook gets exported out of the module so that it can be integrated inot the prompt
def zoxide_hook [] {
  shells
  | where active == true
  | get path
  | each { | path | zoxide add -- $path  }
  | ignore
}

# =============================================================================

# Jump to a directory using only keywords.
def-env zoxide_jump [...rest:string] {
let span = (metadata $rest).span
  #normalize path
  let pwd = ($env.PWD | path expand)
  let z_jump = ( do --ignore-errors { zoxide query --exclude $pwd -- $rest } )

  if ($z_jump | empty?) {
    error make {
      msg: "Zoxide could not find any match for the given query.",
      label: {
        text: "no matches for this query",
        start: $span.start,
        end: $span.end
      }
    }
  }

  # zoxide returns even single results with a newline at the end...
  cd ($z_jump | str trim --right --char (char newline) )
}

alias z = zoxide_jump

# Map of paths to icons.
# These will be used to replace certain path segments in the prompt for example.
# Order these paths for precedence.
let icons = [ 
              [path icon];
              [/home/oli/Workspace "🧬"]
              [/home/oli "🏡"]
            ]

# Uses a special escape code to set the window title of the terminal emulator.
# This will be ignored in terminal emulator, that do not support that escape code.
# The title to be set is derived from the current working directory.
# Special types of directories, e.g. HOME, get custom icons.
def set_window_title [] {
    # normalize path
    let pwd = ( $env.PWD | path expand )
    let icon = if ($icons | any? path == $pwd) { ( $icons | where path == $pwd | get icon.0 ) } else { "📁" }
    echo ([ (ansi title) $icon " " ( $pwd | path basename ) (ansi reset) ] | str collect)
}

def get_vcs_path [] {
    #normalize path
    let pwd = ($env.PWD | path expand)  

    let svn_relative_cmd = ( do --ignore-errors { svn info --show-item relative-url --no-newline $pwd } | complete )
    let svn_relative_path = if ($svn_relative_cmd.exit_code == 0) { $" 🐢 ($svn_relative_cmd.stdout)" }
  
    let git_status = ( gstat )
    let git_branch = if ( $git_status.branch != "no_branch" ) { $"  ($git_status.branch)" }

    [
      $svn_relative_path
      $git_branch
    ] | str collect
}

def create_left_prompt [] {

    zoxide_hook

    set_window_title

    # normalize path
    let pwd = ($env.PWD | path expand)
    let pwd = ($icons | reduce --fold $pwd { |item, accumulator| $accumulator | str find-replace $item.path $item.icon })
    let truncate_level = 5
    let truncate_symbol = "…/"
    let path_segment = if ($pwd | path split | length) >= $truncate_level { ($pwd | path dirname --num-levels 2 --replace $truncate_symbol ) } else { $pwd }
    
    let vcs_segment = get_vcs_path

    [ 
      (ansi dark_gray)
      $path_segment
      (ansi reset)
      (ansi green)
      $vcs_segment
      (ansi reset)
    ] | str collect
}

def create_right_prompt [] {
    let time_segment = ([
        (date now | date format '%d.%m %R')
    ] | str collect)
  
    let command_status_segment = if $env.LAST_EXIT_CODE == 0 { " ✔ " } else { $"(ansi red) ✖ (ansi reset)" }
    let command_duration_segment = if ($env.CMD_DURATION_MS|into int) > 50 { build-string $"($env.CMD_DURATION_MS)ms" | into duration }  

    [ 
      (ansi red_bold)
      $command_duration_segment
      (ansi reset)
      (ansi dark_gray)
      $command_status_segment
      (ansi reset)
      (ansi dark_gray)
      $time_segment
      (ansi reset)
    ] | str collect
}

# Use nushell functions to define your right and left prompt
let-env PROMPT_COMMAND = { create_left_prompt }
let-env PROMPT_COMMAND_RIGHT = { create_right_prompt }

# The prompt indicators are environmental variables that represent
# the state of the prompt
let-env PROMPT_INDICATOR = $"(ansi purple) · (ansi reset)"
let-env PROMPT_INDICATOR_VI_INSERT = $"(ansi purple_reverse) : (ansi reset)"
let-env PROMPT_INDICATOR_VI_NORMAL = $"(ansi purple_bold) · (ansi reset)"
let-env PROMPT_MULTILINE_INDICATOR = $"(ansi purple_dimmed)·· (ansi reset)"

# Specifies how environment variables are:
# - converted from a string to a value on Nushell startup (from_string)
# - converted from a value back to a string when running external commands (to_string)
# Note: The conversions happen *after* config.nu is loaded
let-env ENV_CONVERSIONS = {
  "PATH": {
    from_string: { |s| $s | split row (char esep) }
    to_string: { |v| $v | str collect (char esep) }
  }
  "Path": {
    from_string: { |s| $s | split row (char esep) }
    to_string: { |v| $v | str collect (char esep) }
  }
}

# for more information on themes see
# https://github.com/nushell/nushell/blob/main/docs/How_To_Coloring_and_Theming.md
let default_theme = {
    # color for nushell primitives
    separator: white
    leading_trailing_space_bg: { attr: n } # no fg, no bg, attr non effectively turns this off
    header: green_bold
    empty: blue
    bool: white
    int: white
    filesize: white
    duration: white
    date: white
    range: white
    float: white
    string: white
    nothing: white
    binary: white
    cellpath: white
    row_index: green_bold
    record: white
    list: white
    block: white
    hints: dark_gray

    # shapes are used to change the cli syntax highlighting
    shape_garbage: { fg: "#FFFFFF" bg: "#FF0000" attr: b}
    shape_binary: purple_bold
    shape_bool: light_cyan
    shape_int: purple_bold
    shape_float: purple_bold
    shape_range: yellow_bold
    shape_internalcall: cyan_bold
    shape_external: cyan
    shape_externalarg: green_bold
    shape_literal: blue
    shape_operator: yellow
    shape_signature: green_bold
    shape_string: green
    shape_string_interpolation: cyan_bold
    shape_datetime: cyan_bold
    shape_list: cyan_bold
    shape_table: blue_bold
    shape_record: cyan_bold
    shape_block: blue_bold
    shape_filepath: cyan
    shape_globpattern: cyan_bold
    shape_variable: purple
    shape_flag: blue_bold
    shape_custom: green
    shape_nothing: light_cyan
}

# The default config record. This is where much of your global configuration is setup.
let $config = {
  filesize_metric: false
  table_mode: light # basic, compact, compact_double, light, thin, with_love, rounded, reinforced, heavy, none, other
  use_ls_colors: true
  rm_always_trash: true
  color_config: $default_theme
  use_grid_icons: true
  footer_mode: "auto" # always, never, number_of_rows, auto
  quick_completions: false # set this to false to prevent auto-selecting completions when only one remains
  partial_completions: false # set this to false to prevent partial filling of the prompt
  animate_prompt: false # redraw the prompt every second
  float_precision: 2
  use_ansi_coloring: true
  filesize_format: "auto" # b, kb, kib, mb, mib, gb, gib, tb, tib, pb, pib, eb, eib, zb, zib, auto
  edit_mode: emacs # emacs, vi
  max_history_size: 10000
  menu_config: {
    columns: 4
    col_width: 20   # Optional value. If missing all the screen width is used to calculate column width
    col_padding: 2
    text_style: cyan
    selected_text_style: cyan_reverse
    marker: " | "
  }
  history_config: {
    page_size: 10
    selector: "!"
    text_style: cyan
    selected_text_style: cyan_reverse
    marker: "? "
  }
  keybindings: [
    {
      name: completion_menu
      modifier: none
      keycode: tab
      mode: emacs # Options: emacs vi_normal vi_insert
      event: {
        until: [
          { send: menu name: completion_menu }
          { send: menunext }
        ]
      }
    }
    {
      name: completion_previous
      modifier: shift
      keycode: backtab
      mode: [emacs, vi_normal, vi_insert] # Note: You can add the same keybinding to all modes by using a list
      event: { send: menuprevious }
    }
    {
      name: history_menu
      modifier: control
      keycode: char_x
      mode: emacs
      event: {
        until: [
          { send: menu name: history_menu }
          { send: menupagenext }
        ]
      }
    }
    {
      name: history_previous
      modifier: control
      keycode: char_z
      mode: emacs
      event: {
        until: [
          { send: menupageprevious }
          { edit: undo }
        ]
      }
    }
    {
      name: reload_config
      modifier: none
      keycode: f5
      mode: emacs
      event: {
        send: executehostcommand,
        cmd: $"source '($nu.config-path)'"
      }
    } 
  ]
}
